= opentracing-c

image:https://travis-ci.org/opentracing/opentracing-c.svg?branch=master["Build Status", link="https://travis-ci.org/opentracing/opentracing-c"]
image:https://codecov.io/gh/opentracing/opentracing-c/branch/master/graph/badge.svg["Coverage", link="https://codecov.io/gh/opentracing/opentracing-c"]

ANSI C implementation of the OpenTracing API http://opentracing.io.

== Required Reading

In order to understand the C platform API, one must first be familiar with the
[OpenTracing project](http://opentracing.io) and
[terminology](http://opentracing.io/documentation/pages/spec) more generally.

== Doxygen

API docs generated using Doxygen are hosted
[here](opentracing.github.io/opentracing-c) on GitHub pages.

== Compile and install

```
mkdir build
cd build
cmake ..
make
sudo make install
```

To test:

```
make test
```

== API overview for those adding instrumentation

Everyday consumers of this `opentracing-c` package really only need to worry
about a couple of key abstractions: the `opentracing_tracer` `start_span`
function, the `opentracing_span` interface, and binding an `opentracing_tracer`
at `main()`-time. Here are code snippets demonstrating some important use cases.

=== Singleton initialization

The simplest starting point is `opentracing-c/tracer.h`. As early as possible,
call

:sourcedir: examples

[source,c]
----
include::{sourcedir}/main.c[]
----

=== Non-singleton initialization

If you prefer direct control to singletons, manage ownership of the
`opentracing_tracer` implementation explicitly.

=== Starting an empty trace by creating a "root span"

It's always possible to create a "root" `opentracing_span` with no parent or
other causal reference.

[source,c]
----
include::{sourcedir}/new_span.c[]
----

==== Creating a (child) span given an existing (parent) span

[source,c]
----
include::{sourcedir}/existing_span.c[]
----

==== Inject span context into an opentracing_text_map_writer

[source,c]
----
include::{sourcedir}/inject.c[]
----

==== Extract span context from an opentracing_text_map_reader

```c
    /* See text_map struct and more of its functions above. */

    /* Opaque iterator to iterate through entries in text_map. */
    typedef struct text_map_iterator text_map_iterator;

    /* Get a text_map_iterator from text_map. Returns valid iterator pointer
       on success, NULL on failure. */
    text_map_iterator* text_map_get_iterator(const text_map* map);

    /* Destroy a text_map_iterator returned from text_map_get_iterator. */
    void text_map_iterator_destroy(text_map_iterator* it);

    /* Returns opentracing_true if there are more entries to iterate through,
       opentracing_false otherwise. */
    opentracing_bool text_map_iterator_has_next(const text_map_iterator* it);

    /* Moves iterator to next entry, setting key pointer to next key and value
       pointer to next value. Undefined behavior if text_map_iterator_has_next
       returned opentracing_false (i.e. no valid entries left). */
    void text_map_iterator_next(
        text_map_iterator* it, const char** key_ptr, const char** value_ptr);

    typedef struct custom_carrier_reader {
        /* OPENTRACINGC_TEXT_MAP_READER_SUBCLASS expands to this function
           pointer. Not using macro for clarity. */
        opentracing_bool (*foreach_key)(opentracing_text_map_reader* reader,
                                        opentracing_bool (*f)(
                                            void*,
                                            const char*,
                                            const char*),
                                        void* arg);
        const text_map* map;
    } custom_carrier_reader;

    opentracing_bool custom_carrier_reader_foreach_key(
        opentracing_text_map_reader* reader,
        opentracing_bool (*f)(void*, const char*, const char*),
        void* arg)
    {
        custom_carrier_reader* r;
        text_map_iterator it;
        const char* key;
        const char* value;
        opentracing_bool success;

        assert(reader != NULL);
        assert(f != NULL);

        r = (custom_carrier_reader*) reader;
        it = text_map_get_iterator(r->map);
        if (it == NULL) {
            /* Failed to allocate iterator. */
            return opentracing_false;
        }

        for (; text_map_iterator_has_next(it);
             text_map_iterator_next(it, &key, &value)) {
            assert(key != NULL);
            assert(value != NULL);
            if (!f(arg, key, value)) {
                success = opentracing_false;
                goto cleanup;
            }
        }

        success = opentracing_true;

    cleanup:
        text_map_iterator_destroy(it);
        return success;
    }

    /* Initialize new reader with existing map. */
    void custom_carrier_reader_init(
        custom_carrier_reader* reader, const text_map* map)
    {
        assert(reader != NULL);
        reader->foreach_key = &custom_carrier_reader_foreach_key;
        reader->map = map;
    }
```
